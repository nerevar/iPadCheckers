<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<link href="favicon.ico" rel="shortcut icon" type="image/x-icon" />
		
		<title>HTML5 iPad Checkers</title>
		
		<script type="text/javascript" src="jquery.min.js"></script>
		<script type="text/javascript">
var canvas = null;
var context = null;
var cb_lastPoints = [];
var CELL_SIZE = 80;
var BOARD_SIZE = CELL_SIZE * 8;
var COLOR_BLACK = '#ededed';
var COLOR_WHITE = '#fff';
var SELECTION_COLOR = '#c0c';
var touching = false; // флаг определяющий нажатие мыши/пальца во время перемещения
var images = {};
var diff_coords = {};
var last_coords = {}; // последние координаты

var avaibleMoves = []; // рассчитываемые возможные ходы шашки
var piecePath = []; // рассчитываемый маршрут шашек при непосредственно ходе

var whiteTurn = true; // флаг определяющий ход
var mustBeat = false; // флаг определяющий, должен ли бить игрок. Определяется после каждого хода
var countBeatenPieces = 0;
var log = null; // объект для логирования сообщений
var pieces; // сами шашки
var directions = ['NE', 'SE', 'SW', 'NW']; // диагонали направления 

var isSelected = -1;

/**
 * Объект шашка 
 */
var Cell = function(x, y, kind, isKing) {
	this.x = x;
	this.y = y;
	this.isKing = isKing ? isKing : false;
	this.isSelected = false;
	this.isWhite = kind == 'black' ? false : true;
	this.isBlack = kind == 'black' ? true : false;
    this.isActive = true;
};

/**
 * Объект логгер для ведения логов
 */
var Logger = function(output_id) {
    this.output = document.getElementById(output_id);

    /**
     * Добавляет текст в окно вывода
     * @param text
     */
    this.add = function(text) {
        this.output.innerHTML +=  text + '<br />';
        this.output.scrollTop = this.output.scrollHeight;
    }
	this.clear = function() {
		this.output.innerHTML = '';
	}
}
			
window.onload = function(){
    init();
	/*var sources = {
		green: "./img/green.png",
		blue: "./img/blue.png"
	};
	
	loadImages(sources, function(){
		init();
	});*/
};

/**
 * Загружает изображения в контекст и вызывает функцию по их заверщению
 * @param sources - массив(объект) изображений
 * @param callback - вызываемая функция
 */
function loadImages(sources, callback){
	var loadedImages = 0;
	var numImages = 0;
	for (var src in sources) {
		numImages++;
	}
	for (var src in sources) {
		images[src] = new Image();
		images[src].onload = function(){
			if (++loadedImages >= numImages) {
				callback();
			}
		};
		images[src].src = sources[src];
	}
}

/**
 * Инициализация шашек
 * Инициализирует контекст, события мыши/пальца, расставляет шашки, начинает новую игру
 */
function init() {
	canvas = document.getElementById("canv");

	if (canvas.getContext) {
		
		context = canvas.getContext('2d');
		
		canvas.onmousedown = onStart;
		canvas.onmousemove = onMove;
		canvas.onmouseup = onStop;
		
		canvas.ontouchstart = onStart;
		canvas.ontouchend = onStop;
		canvas.ontouchmove = onMove; 

        log = new Logger('log_info');
        
		newGame();
		refresh();
        log.add('Начата новая игра');
        log.add('Ход белых');
	}
}

/**
 * Начинает новую игру, присваивает координаты шашкам
 */
function newGame() {
	pieces = [
		new Cell(0, 5, 'white'), new Cell(2, 5, 'white'),
		new Cell(4, 5, 'white'), new Cell(6, 5, 'white'),
		new Cell(1, 6, 'white'), new Cell(3, 6, 'white'),
		new Cell(5, 6, 'white'), new Cell(7, 6, 'white'),
		new Cell(0, 7, 'white'), new Cell(2, 7, 'white'),
		new Cell(4, 7, 'white'), new Cell(6, 7, 'white'),

		new Cell(1, 0, 'black'), new Cell(3, 0, 'black'),
		new Cell(5, 0, 'black'), new Cell(7, 0, 'black'),
		new Cell(0, 1, 'black'), new Cell(2, 1, 'black'),
		new Cell(4, 1, 'black'), new Cell(6, 1, 'black'),
		new Cell(1, 2, 'black'), new Cell(3, 2, 'black'),
		new Cell(5, 2, 'black'), new Cell(7, 2, 'black')];
	
	whiteTurn = true;
	mustBeat = 0;
}

function newMyGame() {
	pieces = [
		new Cell(1, 0, 'white', true), /*new Cell(2, 5, 'white'),
		new Cell(4, 5, 'white'), new Cell(0, 5, 'white'),
		/*new Cell(6, 1, 'white'), new Cell(6, 3, 'white'),
		new Cell(6, 5, 'white'), new Cell(6, 7, 'white'),
		new Cell(7, 0, 'white'), new Cell(7, 2, 'white'),
		new Cell(7, 4, 'white'), new Cell(7, 6, 'white'),*/

		/*new Cell(0, 1, 'black'), new Cell(0, 3, 'black'),
		new Cell(0, 5, 'black'), new Cell(0, 7, 'black'),
		new Cell(1, 0, 'black'), new Cell(1, 2, 'black'),
		new Cell(1, 4, 'black'), new Cell(1, 6, 'black'),*/
		new Cell(3, 2, 'black'), new Cell(5, 4, 'black'),
		new Cell(2, 5, 'black'), new Cell(5, 6, 'black')];
	
	whiteTurn = true;
	mustBeat = 0;
}

/**
 * Процедура перерисовки поля.
 * Перерисовывает поле, шашки, рисует номера клеток
 */
function refresh() {

	if (whiteTurn) {
		$('#info .turn').text('WHITE');
	} else {
		$('#info .turn').text('BLACK');
	}
    
	context.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);
	drawBoard();
	drawPieces();
    drawNumbers();
}

/**
 * Рисует номера клеток
 */
function drawNumbers() {
    context.fillStyle = "#555";
    for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
            context.fillText('[' + j + ';' + i + ']', j * CELL_SIZE + 30, i * CELL_SIZE + 45);
        }
    }
}

/**
 * Рисует все шашки на доске
 */
function drawPieces() {
	for (i in pieces) {
		drawPiece(pieces[i]);
	}
}

/**
 * Рисует доску
 */
function drawBoard(){
    for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
            if (i % 2 != j % 2) {
                context.fillStyle = COLOR_BLACK;
            } else {
                context.fillStyle = COLOR_WHITE;
            }
            context.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
	context.beginPath();
	for (var x = 0.5; x < BOARD_SIZE; x += CELL_SIZE) {
		context.moveTo(x, 0);
		context.lineTo(x, BOARD_SIZE);
	}
	for (var y = 0.5; y < BOARD_SIZE; y += CELL_SIZE) {
		context.moveTo(0, y);
		context.lineTo(BOARD_SIZE, y);
	}
	context.strokeStyle = "#ccc";
	context.stroke();
}

/**
 * Рисует указанную шашку на своём месте на поле
 * @param cell - объект шашки, содержит инфу о КООРДИНАТАХ, о ЦВЕТЕ, о ДАМКЕ, о ВЫДЕЛЕННОЙ шашке
 */
function drawPiece(cell){
    if (! cell.isActive) {
        return;
    }
    
	x = cell.x;
	y = cell.y;
	
	px = CELL_SIZE * x;
	py = CELL_SIZE * y;
	
	if (cell.isSelected) {
        // если шашка выделена

		if (touching) {
		    // шашку двигаем, значит на поле её не рисуем
		} else {
            // шашку просто выделели, рисуем на её же месте обведённую
            cell.isKing ?  drawKingPieceatXY(cell.isWhite, px, py) : drawPieceatXY(cell.isWhite, px, py);
            selectPieceatXY(px, py);
        }
	} else {
		// рисуем обычную шашки
		cell.isKing ?  drawKingPieceatXY(cell.isWhite, px, py) : drawPieceatXY(cell.isWhite, px, py);
	}
}

/**
 * Рисует шашку в указанных координатах
 * @param cell - объект шашки, содержит инфу о ЦВЕТЕ, о ДАМКЕ, о ВЫДЕЛЕННОЙ шашке
 * @param x - X координата верхнего левого угла клетки в пикселах
 * @param y - Y координата верхнего левого угла клетки в пикселах
 */
function drawPieceXY(cell, x, y){
	px = x ? x : 0;
	py = y ? y : 0;
	
    cell.isKing ?  drawKingPieceatXY(cell.isWhite, px, py) : drawPieceatXY(cell.isWhite, px, py);

	if (cell.isSelected) {
		// обводим шашку
        selectPieceatXY(px, py);
	}
}

/**
 * Рисует ДАМКУ в указанных координатах
 * @param isWhite - цвет дамки (true, false) - черная, белая
 * @param x - X координата верхнего левого угла клетки в пикселах
 * @param y - Y координата верхнего левого угла клетки в пикселах
 */
function drawKingPieceatXY(isWhite, x, y){
	px = x ? x : 0;
	py = y ? y : 0;

    drawPieceatXY(isWhite, px, py);

    r = CELL_SIZE / 2;

    context.strokeStyle = '#ffff00';

    context.beginPath();
    context.lineWidth = 10;
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, 20, 0, Math.PI * 2, false);
    context.closePath();
    context.stroke();

    context.strokeStyle = 'black';

    context.lineWidth = 1;
}

/**
 * Рисует фишку в указанных координатах
 * @param isWhite - цвет шашки (true, false) - черная, белая
 * @param x - X координата верхнего левого угла клетки в пикселах
 * @param y - Y координата верхнего левого угла клетки в пикселах
 */
function drawPieceatXY(isWhite, x, y){
	px = x ? x : 0;
	py = y ? y : 0;

	color = isWhite ? '#00ff00' : '#5786cf';

    // обводим шашку
    r = CELL_SIZE / 2;

    context.strokeStyle = 'black';

    context.beginPath();
    context.lineWidth = 4;
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r-14, 0, Math.PI * 2, false);
    context.closePath();
    context.stroke();

    context.beginPath();
    context.lineWidth = 2;
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r-2, 0, Math.PI * 2, false);
    context.closePath();
    context.stroke();

    context.beginPath();
    context.lineWidth = 10;
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r-8, 0, Math.PI * 2, false);
    context.strokeStyle = color;
    context.closePath();
    context.stroke();

    context.lineWidth = 1;
}

/**
 * Обводит фишку как текущую
 * @param px - X координата верхнего левого угла клетки в пикселах
 * @param py - Y координата верхнего левого угла клетки в пикселах
 */
function selectPieceatXY(px, py) {
    context.beginPath();
    r = CELL_SIZE / 2 - 1;
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
    context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
    context.closePath();
    context.strokeStyle = SELECTION_COLOR;
    context.stroke();
}

/**
 * Показывает возможные ходы шашки на поле
 * @param currentMoves - структура дерево ходов шашки
 */
function getRecMoves (currentMoves) {
    if (currentMoves && currentMoves.length > 0) {
        for (k in currentMoves) {

            if (currentMoves[k].moves.length > 0) {
                // двигаемся по ветке ходов
                getRecMoves(currentMoves[k].moves);
            } else {
                // остановились на листе, раскрашиваем его
                fillAvaibleMove(currentMoves[k].x, currentMoves[k].y)
            }
        }
    }
}

/**
 * Подсвечивает указанное поле как доступное для хода
 * @param x - координата по оси абсцисс [0;7]
 * @param y - координата по оси ординат [0;7]
 */
function fillAvaibleMove(x, y) {
    context.beginPath();
    context.strokeStyle = "yellow";
    context.lineWidth = 4;
    context.arc(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2, 0, Math.PI * 2, true);
    context.stroke();
    context.lineWidth = 1;
}

/**
 * Событие при нажатии на поле мышью или пальцем
 * @param e - событие браузера
 */
function onStart(e) {
	if (e.touches) {
		// координаты пальца
		coords = getCoords(e.touches[0]);
	} else {
		// координаты мыши
		coords = getCoords(e);
	}
	last_coords = coords;

    // высчитываем координаты относительные и относительно доски попадания мыши или пальца
	diff_coords = {	x : coords.x - Math.floor(coords.x / CELL_SIZE) * CELL_SIZE, 
					y : coords.y - Math.floor(coords.y / CELL_SIZE) * CELL_SIZE};
	diff_board_coords = {	x : Math.floor(coords.x / CELL_SIZE), 
							y : Math.floor(coords.y / CELL_SIZE)};

	// проверка на попадание в окружность шашки
	if (isHitChecker(diff_coords.x, diff_coords.y)) {
		
		// получаем выбранную шашку
		for (i in pieces) {

            // убираем выделение с других остальных шашек
			if (pieces[i].isSelected) {
				pieces[i].isSelected = false;
			}
            
			if (pieces[i].x == diff_board_coords.x && pieces[i].y == diff_board_coords.y
                && (whiteTurn == pieces[i].isWhite) && pieces[i].isActive)
            {
                // если совпали координаты мыши и шашки и нужный ход
                // шашка становится выделенной
                
				isSelected = i;
				pieces[i].isSelected = true;

                // получаем доступные ходы для шашки
                // TODO: заменить передачу координат на передачу объекта ШАШКА
				if (pieces[i].isKing) {
					log.add('Ход дамки ['+ pieces[i].x +';'+ pieces[i].y +']');
					avaibleMoves = getKingAvaibleMoves({x : pieces[i].x, y : pieces[i].y, isWhite: pieces[i].isWhite});
				} else {
					avaibleMoves = getPieceAvaibleMoves({x : pieces[i].x, y : pieces[i].y, isWhite: pieces[i].isWhite});
				}

                // рисуем доступные ходы
                getRecMoves(avaibleMoves);
			}
		}
		
		touching = true;
	} else {
        /*
        // убираем выделение с других шашек
        if (pieces[i].isSelected) {
            pieces[i].isSelected = false;
        }
        */
    }

    //drawNewPieceXY(coords.x - diff_coords.x, coords.y - diff_coords.y);

	return false;
}

/**
 * Событие при отпускании фишки мышью или пальцем
 * @param e - событие браузера
 */
function onStop(e) {
	e.preventDefault();

    // если до этого было перетаскивание фишки
	if (touching) {
		touching = false;

        // если была выбрана фишка
		if (isSelected >=0 ) {
			new_x = Math.ceil(last_coords.x / CELL_SIZE) - 1;

            // получаем новые координаты на доске в месте отпускания фишки
            if (new_x > 7) new_x = 7;
			if (new_x < 0) new_x = 0;
			
			new_y = Math.ceil(last_coords.y / CELL_SIZE) - 1;
			if (new_y > 7) new_y = 7;
			if (new_y < 0) new_y = 0;

			// переместили шашку, координаты различаются
			if (pieces[isSelected].x != new_x || pieces[isSelected].y != new_y) {

                // формируем маршрут piecePath
                piecePath = [];
                if (canPieceMove(avaibleMoves, new_x, new_y)) {
                    // если таки мы можем перейти в новое место

                    // подсчитываем количество взятых фишек
                    countBeatenPieces = 0;
                    removeBeatenPieces(avaibleMoves, piecePath, 0, new_x, new_y);

                    // обязаны ли мы бить?
                    if (mustBeat > 0) {
                        if (countBeatenPieces == 0) {
                            log.add("Недопустимый ход, Вы обязаны бить!");
                            refresh();
                            return false;
                        }
                    }

                    // все ништяк, меняем координаты шашки
                    pieces[isSelected].x = new_x;
                    pieces[isSelected].y = new_y;

                    // снимаем выделение, проверяем на дамку
                    pieces[isSelected].isSelected = false;
                    pieces[isSelected].isKing = isKing(pieces[isSelected]);
                    isSelected = -1;

					// Победа какого-либо игрока
					if (victory = checkVictory()) {
						log.add('Победа ' + (victory == 'white' ? 'белых' : 'черных') + '!');
						
						if (confirm('Начать заново?')) {
							newGame();
							refresh();
							log.clear();
							log.add('Начата новая игра');
							log.add('Ход белых');							
							return;
						} else {
							refresh();
							return;
						}
					}

                    // меняем ход
                    whiteTurn = !whiteTurn;

                    // определяем должен ли бить следующий игрок
                    mustBeat = isPieceMustBeat(whiteTurn);

                    log.add('Ход ' + (whiteTurn ? 'белых' : 'черных') +
                            ((mustBeat > 0) ? ' (обязаны бить '+ mustBeat +')' : '')
                    );

                }
			}

			refresh();
		}
	}
	return false;
}

/**
 * Проверяет может ли фишка переместиться по указанному дереву пути в нужные координаты
 * попутно формирую массив-путь шашки
 * @param currentMoves - рассчитанная структура-"дерево" пути, содержащее все возможные ходы и взятия
 * @param x - координата X куда нужно прийти [0;7]
 * @param y - координата Y куда нужно прийти [0;7]
 */
function canPieceMove(currentMoves, x, y) {
    if (currentMoves && currentMoves.length > 0) {
        for (k in currentMoves) {

            // формируем маршрут
            piecePath.push({x: currentMoves[k].x, y: currentMoves[k].y});

            if (currentMoves[k].moves.length > 0) {
                // можем двигаться дальше по ветке
                return canPieceMove(currentMoves[k].moves, x, y);
            } else {
                // крайний лист дерева

                if (currentMoves[k].x == x && currentMoves[k].y == y) {
                    // если координаты совпали то УРА
                    return currentMoves[k];
                } else {
                    // возвращаемся обратно, тут тупик
                    piecePath.pop();
                }
            }
        }
    }
    return false;
}

/**
 * Убирает побитые фишки
 * @param currentMoves - рекурсивный массив из ходов
 * @param currentPath - текущий ПРОСЧИТАННЫЙ путь шашки
 * @param x - новая X координата
 * @param y - новая Y координата
 */
function removeBeatenPieces(currentMoves, currentPath, currentPathPosition, x, y) {
    if (currentMoves && currentMoves.length > 0) {
        for (k in currentMoves) {
            if (currentMoves[k].x == currentPath[currentPathPosition].x
             && currentMoves[k].y == currentPath[currentPathPosition].y)
            {
                // проверка на то, что текущая координата из возможных координат
                // лежит на маршруте движения фишки

                if (currentMoves[k].beat) {
                    // бьём фишку на пути
                    if (piece_key = getPieceIndexAt(currentMoves[k].beat.x, currentMoves[k].beat.y)) {
						pieces[piece_key].isActive = false;
						countBeatenPieces++;
					}
                }
                if (currentMoves[k].moves.length > 0) {
                    // можем ли мы идти дальше?
                    return removeBeatenPieces(currentMoves[k].moves, currentPath, ++currentPathPosition, x, y);
                }
            } else {
                continue;
            }
        }
    }
}

/**
 * Возвращает номер шашки в массиве по координатам или null если шашка не найдена
 * @param x - координата по оси абсцисс [0;7]
 * @param y - координата по оси ординат [0;7]
 */
function getPieceIndexAt(x, y) {
    for (i in pieces) {
        if (pieces[i].x == x && pieces[i].y == y && pieces[i].isActive) {
            return i;
        }
    }
    return null;
}

/**
 * Событие, вызываемое при перемещении мыши или пальца
 * @param e - событие браузера
 */
function onMove(e) {
	if (e.touches) {
        // координаты пальца
		coords = getCoords(e.touches[0]);
	} else {
        // координаты мыши
		coords = getCoords(e);
	}

    // обновляем переменную с последними координатами мыши
	last_coords = coords;

    // отображаем информацию о курсоре
	$('#info .x').text('X: ' + coords.x); $('#info .cx').text('CX: ' + Math.ceil(coords.x / CELL_SIZE));
	$('#info .y').text('Y: ' + coords.y); $('#info .cy').text('CY: ' + Math.ceil(coords.y / CELL_SIZE));

	if (touching) {
        // при нажатой мыши (перемещению пальцем)

        // получаем координаты рисования перемещаемой шашки
		checker_coords = {	x : coords.x - diff_coords.x,
							y : coords.y - diff_coords.y};

        // перерисовываем доску
		refresh();

		if (isSelected >= 0) {
            // рисуем перемещаемую шашку там где курсор
            pieces[isSelected].isSelected = true;
			drawPieceXY(pieces[isSelected], checker_coords.x, checker_coords.y);
		}
	}

	return false;
}

/**
 * Проверяет, может ли бить шашка/дамка в указанном направлении
 * @return TRUE | FALSE
 */
function canBeatAtDirection(cell, direction) {
	if (cell.isKing) {
		// проверка для дамки
		
		mustGoOn = true;
		
		switch (direction) {
			case 'NE':
				for (kx = cell.x + 1, ky = cell.y - 1; mustGoOn ; kx++, ky--) {
					if (!isValidCell(kx, ky)) {
						// об стенку
						return false;
					}

					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'white' : 'black')) {
						// об свою фишку
						return false;
					}

					// нашли фишку врага на пути
					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'black' : 'white')) 
					{
						// ищем свободное место куда встать
						if (isValidCell(kx + 1, ky - 1) && ! isPieceHere(kx + 1, ky - 1)) {
							return true;
						} else {
							return false;
						}
					}
				}

				break;
			case 'SE':
				for (kx = cell.x + 1, ky = cell.y + 1; mustGoOn ; kx++, ky++) {
					if (!isValidCell(kx, ky)) {
						// об стенку
						return false;
					}

					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'white' : 'black')) {
						// об свою фишку
						return false;
					}

					// нашли фишку врага на пути
					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'black' : 'white')) 
					{
						// ищем свободное место куда встать
						if (isValidCell(kx + 1, ky + 1) && ! isPieceHere(kx + 1, ky + 1)) {
							return true;
						} else {
							return false;
						}
					}
				}
				break;
			case 'SW':
				for (kx = cell.x - 1, ky = cell.y + 1; mustGoOn ; kx--, ky++) {
					if (!isValidCell(kx, ky)) {
						// об стенку
						return false;
					}

					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'white' : 'black')) {
						// об свою фишку
						return false;
					}

					// нашли фишку врага на пути
					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'black' : 'white')) 
					{
						// ищем свободное место куда встать
						if (isValidCell(kx - 1, ky + 1) && ! isPieceHere(kx - 1, ky + 1)) {
							return true;
						} else {
							return false;
						}
					}
				}
				break;
			case 'NW':
				for (kx = cell.x - 1, ky = cell.y - 1; mustGoOn ; kx--, ky--) {
					if (!isValidCell(kx, ky)) {
						// об стенку
						return false;
					}

					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'white' : 'black')) {
						// об свою фишку
						return false;
					}

					// нашли фишку врага на пути
					if (isValidCell(kx, ky) && isPieceHere(kx, ky) == (cell.isWhite ? 'black' : 'white')) 
					{
						// ищем свободное место куда встать
						if (isValidCell(kx - 1, ky - 1) && ! isPieceHere(kx - 1, ky - 1)) {
							return true;
						} else {
							return false;
						}
					}
				}
				break;
		}		
	} else {
		// проверка для обычный шашки
		switch (direction) {
			case 'NE':
				if (isValidCell(cell.x + 2, cell.y - 2) && ! isPieceHere(cell.x + 2, cell.y - 2)
					&& isPieceHere(cell.x + 1, cell.y - 1) == (cell.isWhite ? 'black' : 'white')) {
					return true;
				} else {
					return false;
				}
				break;
			case 'SE':
				if (isValidCell(cell.x + 2, cell.y + 2) && ! isPieceHere(cell.x + 2, cell.y + 2)
					&& isPieceHere(cell.x + 1, cell.y + 1) == (cell.isWhite ? 'black' : 'white')) {
					return true;
				} else {
					return false;
				}
				break;
			case 'SW':
				if (isValidCell(cell.x - 2, cell.y + 2) && ! isPieceHere(cell.x - 2, cell.y + 2)
					&& isPieceHere(cell.x - 1, cell.y + 1) == (cell.isWhite ? 'black' : 'white')) {
					return true;
				} else {
					return false;
				}
				break;
			case 'NW':
				if (isValidCell(cell.x - 2, cell.y - 2) && ! isPieceHere(cell.x - 2, cell.y - 2)
					&& isPieceHere(cell.x - 1, cell.y - 1) == (cell.isWhite ? 'black' : 'white')) {
					return true;
				} else {
					return false;
				}
				break;
		}
	}
}

/**
 * Определяет должен ли бить игрок (находятся ли чужие фишки под боем)
 * @param whiteCells - TRUE|FALSE - белые или черные шашки
 */
function isPieceMustBeat(whiteCells) {
    result = 0;
	
	whiteCells = whiteCells ? whiteCells : true;

    for (k in pieces) {

        if (pieces[k].isActive == false) {
            continue;
        }
        // если цвет текущей шашки отличается от нужного нам цвета то идём дальше
        if (pieces[k].isWhite != whiteCells) {
            continue;
        }
		
		// для каждого направления проверяем
		for (dir in directions) {
			if (canBeatAtDirection(pieces[k], directions[dir])) {
				result++;
			}
		}
    }

    return result;
}

/**
 * Рассчитывает все возможные ходы и взятия для указанной шашки
 * @param cell - объект шашка
 */
function getPieceAvaibleMoves(cell) {

    // возможные клетки для перемещения на текущем "прыге"
    var thisTurnMoves = [];

    // Нету предыдущей клетки, откуда прыгали, поэтому проверка обычных ходов без взятия
    if (! cell.parent_x && ! cell.parent_y) {
        if (cell.isWhite) {
            // NE
            if (isValidCell(cell.x + 1, cell.y - 1) && ! isPieceHere(cell.x + 1, cell.y - 1)) {
                thisTurnMoves.push({
                    x: cell.x + 1,
                    y: cell.y - 1,
                    moves:[]
                });
            }
            // NW
            if (isValidCell(cell.x - 1, cell.y - 1) && ! isPieceHere(cell.x - 1, cell.y - 1)) {
                thisTurnMoves.push({
                    x: cell.x - 1,
                    y: cell.y - 1,
                    moves:[]
                });
            }
        } else {
            // SE
            if (isValidCell(cell.x + 1, cell.y + 1) && ! isPieceHere(cell.x + 1, cell.y + 1)) {
                thisTurnMoves.push({
                    x: cell.x + 1,
                    y: cell.y + 1,
                    moves:[]
                });            
			}
            // SW
            if (isValidCell(cell.x - 1, cell.y + 1) && ! isPieceHere(cell.x - 1, cell.y + 1)) {
                thisTurnMoves.push({
                    x: cell.x - 1,
                    y: cell.y + 1,
                    moves:[]
                });
            }
        }
    }

    // взятие NE
    if (cell.y >= 2 && cell.x <= 5
        && (cell.x + 2 != cell.parent_x
			|| cell.y - 2 != cell.parent_y)
        && ((isPieceHere(cell.x + 1, cell.y - 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x + 1, cell.y - 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x + 2, cell.y - 2))
    {
        var pMove = {
            x: cell.x + 2,
            y: cell.y - 2,
            moves:[],
            beat: {
                x: cell.x + 1,
                y: cell.y - 1
            }
        };
        thisTurnMoves.push(pMove);
    }
    // взятие SE
    if (cell.y <= 5 && cell.x <= 5
        && (cell.x + 2 != cell.parent_x
            || cell.y + 2 != cell.parent_y)
        && ((isPieceHere(cell.x + 1, cell.y + 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x + 1, cell.y + 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x + 2, cell.y + 2))
    {
        var pMove = {
            x: cell.x + 2,
            y: cell.y + 2,
            moves:[],
            beat: {
                x: cell.x + 1,
                y: cell.y + 1
            }
        };
        thisTurnMoves.push(pMove);
    }
    // взятие SW
    if (cell.y <= 5 && cell.x >= 2
        && (cell.x - 2 != cell.parent_x
            || cell.y + 2 != cell.parent_y)
        && ((isPieceHere(cell.x - 1, cell.y + 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x - 1, cell.y + 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x - 2, cell.y + 2))
    {
        var pMove = {
            x: cell.x - 2,
            y: cell.y + 2,
            moves:[],
            beat: {
                x: cell.x - 1,
                y: cell.y + 1
            }
        };
        thisTurnMoves.push(pMove);
    }
    // взятие NW
    if (cell.y >= 2 && cell.x >= 2
        && (cell.x - 2 != cell.parent_x
            || cell.y - 2 != cell.parent_y)
        && ((isPieceHere(cell.x - 1, cell.y - 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x - 1, cell.y - 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x - 2, cell.y - 2))
    {
        var pMove = {
            x: cell.x - 2,
            y: cell.y - 2,
            moves:[],
            beat: {
                x: cell.x - 1,
                y: cell.y - 1
            }
        };
        thisTurnMoves.push(pMove);
    }

    for (i in thisTurnMoves) {
        if (thisTurnMoves[i].beat) {
            thisTurnMoves[i].moves = getPieceAvaibleMoves({
                x: thisTurnMoves[i].x,
                y: thisTurnMoves[i].y,
                isWhite: cell.isWhite,
                parent_x : cell.x,
                parent_y: cell.y
            });
        }
    }
    return thisTurnMoves;
}

/**
 * Рассчитывает все возможные ходы и взятия для указанной ДАМКА
 * @param cell - объект шашка (ДАМКА)
 */
function getKingAvaibleMoves(cell) {

    // возможные клетки для перемещения на текущем "прыге"
    var thisTurnMoves = [];

    // Нету предыдущей клетки, откуда прыгали, поэтому проверка обычных ходов без взятия
	// для дамки проверяем сразу диагонали
	if (! cell.parent_x && ! cell.parent_y) {
		// NE
		for (kx = cell.x + 1, ky = cell.y - 1; true ; kx++, ky--) {
			if (isValidCell(kx, ky) && ! isPieceHere(kx, ky)) {
				thisTurnMoves.push({
					x: kx,
					y: ky,
					moves:[]
				});
			} else {
				break;
			}
		}
		// SE
		for (kx = cell.x + 1, ky = cell.y + 1; true ; kx++, ky++) {
			if (isValidCell(kx, ky) && ! isPieceHere(kx, ky)) {
				thisTurnMoves.push({
					x: kx,
					y: ky,
					moves:[]
				});
			} else {
				break;
			}
		}	
		// SW
		for (kx = cell.x - 1, ky = cell.y + 1; true ; kx--, ky++) {
			if (isValidCell(kx, ky) && ! isPieceHere(kx, ky)) {
				thisTurnMoves.push({
					x: kx,
					y: ky,
					moves:[]
				});
			} else {
				break;
			}
		}	
		// NW
		for (kx = cell.x - 1, ky = cell.y - 1; true ; kx--, ky--) {
			if (isValidCell(kx, ky) && ! isPieceHere(kx, ky)) {
				thisTurnMoves.push({
					x: kx,
					y: ky,
					moves:[]
				});
			} else {
				break;
			}
		}			
		
    }

	// Взятия
	
	// белые
	if (cell.isWhite) {

		// SE
		mustGoOn = true;
		for (kx = cell.x + 1, ky = cell.y + 1; mustGoOn ; kx++, ky++) {
			if (!isValidCell(kx, ky)) {
				// останавливаемся об стенку
				mustGoOn = false;
				break;				
			}
			
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'white') {
				// останавливаемся об свою фишку
				mustGoOn = false;
				break;
			}
			
			// нашли фишку врага на пути
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'black' 
				&& (!cell.parent_direction || cell.parent_direction != 'SE') ) 
			{
				for (nx = kx + 1, ny = ky + 1; mustGoOn ; nx++, ny++) {
					if (isValidCell(nx, ny) && ! isPieceHere(nx, ny)) {
						thisTurnMoves.push({
							x: nx,
							y: ny,
							moves:[],
							beat: {
								x: kx,
								y: ky
							}							
						});
					} else {
						mustGoOn = false;
						break;
					}					
				}
				
			}
		}
		
		
		// SW
		mustGoOn = true;
		for (kx = cell.x - 1, ky = cell.y + 1; mustGoOn ; kx--, ky++) {
			if (!isValidCell(kx, ky)) {
				// останавливаемся об стенку
				mustGoOn = false;
				break;				
			}
						
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'white') {
				// останавливаемся об свою фишку
				mustGoOn = false;
				break;
			}
			
			// нашли фишку врага на пути
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'black'
				&& (!cell.parent_direction || cell.parent_direction != 'SW') ) 
			{
				for (nx = kx - 1, ny = ky + 1; mustGoOn ; nx--, ny++) {
					if (isValidCell(nx, ny) && ! isPieceHere(nx, ny)) {
						thisTurnMoves.push({
							x: nx,
							y: ny,
							moves:[],
							beat: {
								x: kx,
								y: ky
							}							
						});
					} else {
						mustGoOn = false;
						break;
					}					
				}
				
			}
		}


		// NW
		mustGoOn = true;
		for (kx = cell.x - 1, ky = cell.y - 1; mustGoOn ; kx--, ky--) {
			if (!isValidCell(kx, ky)) {
				// останавливаемся об стенку
				mustGoOn = false;
				break;				
			}
			
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'white') {
				// останавливаемся об свою фишку
				mustGoOn = false;
				break;
			}
			
			// нашли фишку врага на пути
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'black'
				&& (!cell.parent_direction || cell.parent_direction != 'NW') )  
			{
				for (nx = kx - 1, ny = ky - 1; mustGoOn ; nx--, ny--) {
					if (isValidCell(nx, ny) && ! isPieceHere(nx, ny)) {
						thisTurnMoves.push({
							x: nx,
							y: ny,
							moves:[],
							beat: {
								x: kx,
								y: ky
							}							
						});
					} else {
						mustGoOn = false;
						break;
					}					
				}
				
			}
		}
		
		
		// NE
		mustGoOn = true;
		for (kx = cell.x + 1, ky = cell.y - 1; mustGoOn ; kx++, ky--) {
			if (!isValidCell(kx, ky)) {
				// останавливаемся об стенку
				mustGoOn = false;
				break;				
			}
			
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'white') {
				// останавливаемся об свою фишку
				mustGoOn = false;
				break;
			}
			
			// нашли фишку врага на пути
			if (isValidCell(kx, ky) && isPieceHere(kx, ky) == 'black'
				&& (!cell.parent_direction || cell.parent_direction != 'NE') ) 
			{
				for (nx = kx + 1, ny = ky - 1; mustGoOn ; nx++, ny--) {
					if (isValidCell(nx, ny) && ! isPieceHere(nx, ny)) {
						thisTurnMoves.push({
							x: nx,
							y: ny,
							moves:[],
							beat: {
								x: kx,
								y: ky
							}							
						});
					} else {
						mustGoOn = false;
						break;
					}					
				}
				
			}
		}


	}


    for (i in thisTurnMoves) {
        if (thisTurnMoves[i].beat) {
            thisTurnMoves[i].moves = getKingAvaibleMoves({
                x: thisTurnMoves[i].x,
                y: thisTurnMoves[i].y,
                isWhite: cell.isWhite,
                parent_x : cell.x,
                parent_y: cell.y,
				parent_direction : getDirection({x: cell.x, y:cell.y}, {x: thisTurnMoves[i].x, y: thisTurnMoves[i].y})
            });
        }
    }
    return thisTurnMoves;
}

/**
 * Возвращает направление между двумя шашками:
 * NE, SE, SW, NW
 * от второй шашке к первой
 */
function getDirection(cell1, cell2) {
	if (cell2.x > cell1.x && cell2.y > cell1.y) return 'NW';
	if (cell2.x < cell1.x && cell2.y > cell1.y) return 'NE';
	if (cell2.x < cell1.x && cell2.y < cell1.y) return 'SE';
	if (cell2.x > cell1.x && cell2.y < cell1.y) return 'SW';
}

/**
 * Определяет является ли шашка дамкой
 * @param cell - объект шашка
 */
function isKing(cell) {
    if (cell.isKing) {
        return true;
    }
    if (cell.isWhite && cell.y == 0) {
        return true;
    }
    if (! cell.isWhite && cell.y == 7) {
        return true;
    }
    return false;

}

/**
 * Рисует линию по двум точкам
 * @param sX - X координата 1-й точки
 * @param sY - Y координата 1-й точки
 * @param eX - X координата 2-й точки
 * @param eY - Y координата 2-й точки
 */
function drawLine(sX, sY, eX, eY) {
	context.moveTo(sX, sY);
	context.lineTo(eX, eY);
	return { x: eX, y: eY };
}

/**
 * Возвращает координаты мыши или пальца относительно доски в пикселях, кроссбраузерно
 * @param e - событие браузера
 */
function getCoords(e) {
	if (e.pageX == null && e.clientX != null ) {
        // IE fix
		var html = document.documentElement
		var body = document.body
	
		e.pageX = e.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
		e.pageY = e.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
	}
	return { x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop };
}

/**
 * Проверяет попадание координат в круг с радиусом CELL_SIZE
 * @param x - координата по оси абсцисс [0;7]
 * @param y - координата по оси ординат [0;7]
 */
function isHitChecker(x, y) {
	return Math.sqrt(Math.pow(x - (CELL_SIZE / 2), 2) + Math.pow(y - (CELL_SIZE / 2), 2)) <= (CELL_SIZE / 2);
}

/**
 * Проверяет указанную клетку на наличие в ней фишки определенного цвета
 * Возвращает 'white' или 'black' при наличии шашки соответствующего цвета
 * или false если клетка пустая или координаты не принадлежат доске
 * @param x - координата по оси абсцисс [0;7]
 * @param y - координата по оси ординат [0;7]
 */
function isPieceHere(x, y) {
    if (! isValidCell(x, y)) {
        return false;
    }
    
    for (i in pieces) {
        if (pieces[i].x == x && pieces[i].y == y && pieces[i].isActive) {
            return pieces[i].isWhite ? 'white' : 'black';
        }
    }
    return false;
}

/**
 * Проверяет координаты на принадлежность доске и возвращает булевское значение
 * @param x - координата по оси абсцисс [0;7]
 * @param y - координата по оси ординат [0;7]
 */
function isValidCell(x, y) {
    return (x >= 0 && x <= 7 && y >= 0 && y <= 7) ? true : false;
}

/**
 * Проверяет количество шашек и определяет победу
 */
function checkVictory() {
	var count_black = count_white = 0;
	
	for (i in pieces) {
		if (pieces[i].isActive) {
			if (pieces[i].isWhite) {
				count_white++;
			} else {
				count_black++;
			}
		}
	}
	
	if (count_black == 0) return 'white';
	if (count_white == 0) return 'black';
	return false;
}

		</script>
		<style type="text/css" media="screen">
			body {
				font: 14px Verdana;
			}
			#wrap {
				/*width: 768px;*/
				max-height: 1024px;
				overflow: hidden;
                position: relative;
			}
			#canv_wrap {
				border: 1px solid #777;
				width: 640px;
				margin: 0px 0px 0px 64px;
			}
			#info {
				position:absolute;
			}
            #log_info {
                position: absolute;
                top: 0px;
                left: 740px;
                width: 300px;
                height: 500px;
                border: 1px solid black;
                background-color: #ededed;
                padding: 10px;
                overflow-x: hidden;
                overflow-y: scroll;
            }
		</style>
	</head>
	<body>
		<div id="wrap">		
			<div id="info">
				<div class="turn"></div>
				<div class="x"></div>
				<div class="y"></div>
				<div class="cx"></div>
				<div class="cy"></div>
				<div class="text"></div>
                <div class="event"></div>
			</div>
			
			<div id="canv_wrap">
				<canvas id="canv" width="640" height="640"></canvas>
			</div>

			<div id="log_info">
                
			</div>
		
		</div>
	</body>
</html>