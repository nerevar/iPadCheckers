<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<title>HTML5 iPad Checkers</title>
		
		<script type="text/javascript" src="jquery.min.js"></script>
		<script type="text/javascript">
var canvas = null;
var context = null;
var cb_lastPoints = [];
var CELL_SIZE = 80;
var BOARD_SIZE = CELL_SIZE * 8;
var COLOR_BLACK = '#ededed';
var COLOR_WHITE = '#fff';
var SELECTION_COLOR = '#c0c';
var touching = false;
var images = {};
var diff_coords = {};
var last_coords = {};

var avaibleMoves = [];

var whiteTurn = true;

var pieces;

var isSelected = -1;

var Cell = function(y, x, kind) {
	this.y = y;
	this.x = x;
	this.isKing = false;
	this.isSelected = false;
	this.isWhite = kind == 'black' ? false : true;
	this.isBlack = kind == 'black' ? true : false;
    this.isActive = true;
};
			
window.onload = function(){
	var sources = {
		green: "./img/green.png",
		blue: "./img/blue.png"
	};
	
	loadImages(sources, function(){
		init();
	});
};


function loadImages(sources, callback){
	var loadedImages = 0;
	var numImages = 0;
	for (var src in sources) {
		numImages++;
	}
	for (var src in sources) {
		images[src] = new Image();
		images[src].onload = function(){
			if (++loadedImages >= numImages) {
				callback();
			}
		};
		images[src].src = sources[src];
	}
}

function init() {
	canvas = document.getElementById("canv");

	pieces = [
		new Cell(5, 0, 'white'), new Cell(5, 2, 'white'),
		new Cell(5, 4, 'white'), new Cell(5, 6, 'white'),
		new Cell(6, 1, 'white'), new Cell(6, 3, 'white'),
		new Cell(6, 5, 'white'), new Cell(6, 7, 'white'),
		new Cell(7, 0, 'white'), new Cell(7, 2, 'white'),
		new Cell(7, 4, 'white'), new Cell(7, 6, 'white'),
		
		new Cell(0, 1, 'black'), new Cell(0, 3, 'black'),
		new Cell(0, 5, 'black'), new Cell(0, 7, 'black'),
		new Cell(1, 0, 'black'), new Cell(1, 2, 'black'),
		new Cell(1, 4, 'black'), new Cell(1, 6, 'black'),
		new Cell(2, 1, 'black'), new Cell(2, 3, 'black'),
		new Cell(2, 5, 'black'), new Cell(2, 7, 'black')];
	
	if (canvas.getContext) {
		
		context = canvas.getContext('2d');
		
		canvas.onmousedown = onStart;
		canvas.onmousemove = onMove;
		canvas.onmouseup = onStop;
		
		canvas.ontouchstart = onStart;
		canvas.ontouchend = onStop;
		canvas.ontouchmove = onMove;
		
		refresh();
	}
}

function log(smth) {
	$('#info .text').html($('#info .text').html() + ' | ' + smth);
}

function refresh() {

	if (whiteTurn) {
		$('#info .turn').text('WHITE');
	} else {
		$('#info .turn').text('BLACK');
	}
    
	context.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);
	drawBoard();
	drawPieces();

    drawNumbers();
}

function drawNumbers() {
    context.fillStyle = "#555";
    for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
            context.fillText('[' + j + ';' + i + ']', j * CELL_SIZE + 30, i * CELL_SIZE + 45);
        }
    }
}

function drawPieces() {
	for (i in pieces) {
		drawPiece(pieces[i]);
	}
}

function drawBoard(){
    for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
            if (i % 2 != j % 2) {
                context.fillStyle = COLOR_BLACK;
            } else {
                context.fillStyle = COLOR_WHITE;
            }
            context.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
	context.beginPath();
	for (var x = 0.5; x < BOARD_SIZE; x += CELL_SIZE) {
		context.moveTo(x, 0);
		context.lineTo(x, BOARD_SIZE);
	}
	for (var y = 0.5; y < BOARD_SIZE; y += CELL_SIZE) {
		context.moveTo(0, y);
		context.lineTo(BOARD_SIZE, y);
	}
	context.strokeStyle = "#ccc";
	context.stroke();
}

function drawPiece(cell){
    if (! cell.isActive) {
        return;
    }
    
	x = cell.x;
	y = cell.y;
	
	px = CELL_SIZE * x;
	py = CELL_SIZE * y;
	
	piece = cell.isWhite ? images.green : images.blue;
	if (cell.isSelected) {
		// шашку двигаем, значит на поле её не рисуем
		if (!touching) {
			context.drawImage(piece, px , py);
			
			// обводим шашку
			context.beginPath();
			r = CELL_SIZE / 2 - 1;
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.closePath();
			context.strokeStyle = SELECTION_COLOR;
			context.stroke();			
		}
	} else {
		// рисуем обычную шашки
		context.drawImage(piece, px , py);
	}
}

function drawPieceXY(cell, x, y){
	px = x ? x : 0;
	py = y ? y : 0;
	
	piece = cell.isWhite ? images.green : images.blue;
	context.drawImage(piece, px , py);
	
	if (cell.isSelected) {
		// обводим шашку
		context.beginPath();
		r = CELL_SIZE / 2 - 1;
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.closePath();
		context.strokeStyle = SELECTION_COLOR;
		context.stroke();		
	}
}

function getRecMoves (currentMoves) {
    if (currentMoves && currentMoves.length > 0) {
        for (k in currentMoves) {

            if (currentMoves[k].moves.length > 0) {
                getRecMoves(currentMoves[k].moves);
            } else {
                fillAvaibleMove(currentMoves[k].x, currentMoves[k].y)
            }
        }
    }
}

function fillAvaibleMove(x, y) {
    context.beginPath();
    context.strokeStyle = "yellow";
    context.lineWidth = 4;
    context.arc(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2, 0, Math.PI * 2, true);
    context.stroke();
    context.lineWidth = 1;
}

function onStart(e) {
	if (e.touches) {
		// Touch event
		coords = getCoords(e.touches[0]); // Get info for finger #1
	} else {
		// Mouse event
		coords = getCoords(e);
	}
	last_coords = coords;

	diff_coords = {	x : coords.x - Math.floor(coords.x / CELL_SIZE) * CELL_SIZE, 
					y : coords.y - Math.floor(coords.y / CELL_SIZE) * CELL_SIZE};
	diff_board_coords = {	x : Math.floor(coords.x / CELL_SIZE), 
							y : Math.floor(coords.y / CELL_SIZE)};

    //$('#info .event').text($('#info .event').text() + '| ' + e.type);

	// проверка на попадание в шашку
	if (isHitChecker()) {
		
		// получаем выбранную шашку
		for (i in pieces) {
            // убираем выделение с других шашек
			if (pieces[i].isSelected) {
				pieces[i].isSelected = false;
			}
            
			if (pieces[i].x == diff_board_coords.x && pieces[i].y == diff_board_coords.y
                && (whiteTurn == pieces[i].isWhite))
            {
				isSelected = i;
				pieces[i].isSelected = true;

                // получаем доступные ходы для шашки
                avaibleMoves = getAvaibleMoves({x : pieces[i].x, y : pieces[i].y, isWhite: pieces[i].isWhite});

                // рисуем доступные ходы
                getRecMoves(avaibleMoves);
			}
		}
		
		touching = true;
	} else {
        /*
        // убираем выделение с других шашек
        if (pieces[i].isSelected) {
            pieces[i].isSelected = false;
        }
        */
    }
	
	return false;
}

// Called whenever cursor position changes after drawing has started
function onStop(e) {
	e.preventDefault();
	
	if (touching) {
		touching = false;

		if (isSelected >=0 ) {
			
			new_x = Math.ceil(last_coords.x / CELL_SIZE) - 1;
			if (new_x > 7) new_x = 7;
			if (new_x < 0) new_x = 0;
			
			new_y = Math.ceil(last_coords.y / CELL_SIZE) - 1;
			if (new_y > 7) new_y = 7;
			if (new_y < 0) new_y = 0;

			// переместили шашку
			if (pieces[isSelected].x != new_x || pieces[isSelected].y != new_y) {
                if (canPieceMove(avaibleMoves, new_x, new_y)) {

                    removeBeatenPieces(avaibleMoves, new_x, new_y);
                    pieces[isSelected].x = new_x;
                    pieces[isSelected].y = new_y;

                    pieces[isSelected].isSelected = false;
                    pieces[isSelected].isKing = isKing(pieces[isSelected]);
                    isSelected = -1;

                    whiteTurn = !whiteTurn;
                }
			}

			refresh();
		}
	}
	return false;
}

function canPieceMove(currentMoves, x, y) {
    if (currentMoves && currentMoves.length > 0) {
        for (k in currentMoves) {

            if (currentMoves[k].moves.length > 0) {
                return canPieceMove(currentMoves[k].moves, x, y);
            } else {
                if (currentMoves[k].x == x && currentMoves[k].y == y) {
                    return currentMoves[k];
                }
            }
        }
    }
    return false;
}

function removeBeatenPieces(currentMoves, x, y) {
    if (currentMoves && currentMoves.length > 0) {
        for (k in currentMoves) {
            if (currentMoves[k].beat) {
                piece_key = getPieceIndexAt(currentMoves[k].beat.x, currentMoves[k].beat.y);
                pieces[piece_key].isActive = false;
                pieces[piece_key].x = -1;
                pieces[piece_key].y = -1;
            }
            if (currentMoves[k].moves.length > 0) {
                return removeBeatenPieces(currentMoves[k].moves, x, y);
            }
        }
    }
}

function getPieceIndexAt(x, y) {
    for (i = 0; i < 24; i++){
        if (pieces[i].x == x && pieces[i].y == y) {
            return i;
        }
    }
    return null;
}


function onMove(e) {
	if (e.touches) {
		// Touch Enabled
		coords = getCoords(e.touches[0]); // Get info for finger i
	} else {
		coords = getCoords(e);
	}

	last_coords = coords;

	$('#info .x').text('X: ' + coords.x); $('#info .cx').text('CX: ' + Math.ceil(coords.x / CELL_SIZE));
	$('#info .y').text('Y: ' + coords.y); $('#info .cy').text('CY: ' + Math.ceil(coords.y / CELL_SIZE));


	if (touching) {
		checker_coords = {	x : coords.x - diff_coords.x,
							y : coords.y - diff_coords.y};

		refresh();

		if (isSelected >= 0) {
            pieces[isSelected].isSelected = true;
			drawPieceXY(pieces[isSelected], checker_coords.x, checker_coords.y);
		}
	}

	return false;
}

function getAvaibleMoves(cell) {

    var thisTurnMoves = [];
    
    if (! cell.parent_x && ! cell.parent_y) {
        // Проверяем доступные простые ходы
        if (cell.isWhite) {
            if (cell.y >= 1 && cell.x <= 6 && ! isPieceHere(cell.x + 1, cell.y - 1)) {
                var pMove = {
                    x: cell.x + 1,
                    y: cell.y - 1,
                    moves:[]
                };
                thisTurnMoves.push(pMove);
            }
            if (cell.y >= 1 && cell.x >= 1 && ! isPieceHere(cell.x - 1, cell.y - 1)) {
                var pMove = {
                    x: cell.x - 1,
                    y: cell.y - 1,
                    moves:[]
                };
                thisTurnMoves.push(pMove);
            }
        } else {
            if (cell.y <= 6 && cell.x <= 6 && ! isPieceHere(cell.x + 1, cell.y + 1)) {
                var pMove = {
                    x: cell.x + 1,
                    y: cell.y + 1,
                    moves:[]
                };
                thisTurnMoves.push(pMove);
            }
            if (cell.y <= 6 && cell.x >= 1 && ! isPieceHere(cell.x - 1, cell.y + 1)) {
                var pMove = {x: 0, y: 0, moves:[]};
                var pMove = {
                    x: cell.x - 1,
                    y: cell.y + 1,
                    moves:[]
                };
                thisTurnMoves.push(pMove);
            }
        }
    }

    // взятие NE
    if (cell.y >= 2 && cell.x <= 5
        && (cell.x + 2 != cell.parent_x
        && cell.y - 2 != cell.parent_y)
        && ((isPieceHere(cell.x + 1, cell.y - 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x + 1, cell.y - 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x + 2, cell.y - 2))
    {
        var pMove = {
            x: cell.x + 2,
            y: cell.y - 2,
            moves:[],
            beat: {
                x: cell.x + 1,
                y: cell.y - 1
            }
        };
        thisTurnMoves.push(pMove);
    }
    // взятие SE
    if (cell.y <= 5 && cell.x <= 5
        && (cell.x + 2 != cell.parent_x
            || cell.y + 2 != cell.parent_y)
        && ((isPieceHere(cell.x + 1, cell.y + 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x + 1, cell.y + 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x + 2, cell.y + 2))
    {
        var pMove = {
            x: cell.x + 2,
            y: cell.y + 2,
            moves:[],
            beat: {
                x: cell.x + 1,
                y: cell.y + 1
            }
        };
        thisTurnMoves.push(pMove);
    }
    // взятие SW
    if (cell.y <= 5 && cell.x >= 2
        && (cell.x - 2 != cell.parent_x
            || cell.y + 2 != cell.parent_y)
        && ((isPieceHere(cell.x - 1, cell.y + 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x - 1, cell.y + 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x - 2, cell.y + 2))
    {
        var pMove = {
            x: cell.x - 2,
            y: cell.y + 2,
            moves:[],
            beat: {
                x: cell.x - 1,
                y: cell.y + 1
            }
        };
        thisTurnMoves.push(pMove);
    }
    // взятие NW
    if (cell.y >= 2 && cell.x >= 2
        && (cell.x - 2 != cell.parent_x
            || cell.y - 2 != cell.parent_y)
        && ((isPieceHere(cell.x - 1, cell.y - 1) == 'black' && cell.isWhite)
            || (isPieceHere(cell.x - 1, cell.y - 1) == 'white' && ! cell.isWhite))
        && ! isPieceHere(cell.x - 2, cell.y - 2))
    {
        var pMove = {
            x: cell.x - 2,
            y: cell.y - 2,
            moves:[],
            beat: {
                x: cell.x - 1,
                y: cell.y - 1
            }
        };
        thisTurnMoves.push(pMove);
    }

    for (i in thisTurnMoves) {
        if (thisTurnMoves[i].beat) {
            thisTurnMoves[i].moves = getAvaibleMoves({x: thisTurnMoves[i].x, y: thisTurnMoves[i].y, isWhite: cell.isWhite, parent_x : cell.x, parent_y: cell.y});
        }
    }
    return thisTurnMoves;
}

// Определяет является ли шашка дамкой
function isKing(cell) {
    if (cell.isKing) {
        return true;
    }
    if (cell.isWhite && cell.y == 0) {
        return true;
    }
    if (! cell.isWhite && cell.y == 7) {
        return true;
    }
    return false;

}

// Draw a line on the canvas from (s)tart to (e)nd
function drawLine(sX, sY, eX, eY) {
	context.moveTo(sX, sY);
	context.lineTo(eX, eY);
	return { x: eX, y: eY };
}

// Get the coordinates for a mouse or touch event
function getCoords(e) {
	if (e.pageX == null && e.clientX != null ) { 
		var html = document.documentElement
		var body = document.body
	
		e.pageX = e.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
		e.pageY = e.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
	}
	return { x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop };
	
	/*if (e.offsetX) {
		return { x: e.offsetX, y: e.offsetY };
	}
	else if (e.layerX) {
		return { x: e.layerX, y: e.layerY };
	}
	else {
		return { x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop };
	}*/
}

function isHitChecker() {
	return Math.sqrt(Math.pow(diff_coords.x - (CELL_SIZE / 2), 2) + Math.pow(diff_coords.y - (CELL_SIZE / 2), 2)) <= (CELL_SIZE / 2);
}

function canMove(piece, x, y) {
    return true;
}
function isPieceHere(x, y) {
    for (i in pieces) {
        if (pieces[i].x == x && pieces[i].y == y) {
            return pieces[i].isWhite ? 'white' : 'black';
        }
    }
    return false;
}

		</script>
		<style type="text/css" media="screen">
			body {
				font: 14px Verdana;
			}
			#wrap {
				width: 768px;
				max-height: 1024px;
				overflow: hidden;
			}
			#canv_wrap {
				border: 1px solid #777;
				width: 640px;
				margin: 0px auto 0px;
			}
			#info {
				position:absolute;
			}
		</style>
	</head>
	<body>
		<div id="wrap">		
			<div id="info">
				<div class="turn"></div>
				<div class="x"></div>
				<div class="y"></div>
				<div class="cx"></div>
				<div class="cy"></div>
				<div class="text"></div>
                <div class="event"></div>
			</div>
			
			<div id="canv_wrap">
				<canvas id="canv" width="640" height="640"></canvas>
			</div>

			
		
		</div>
	</body>
</html>