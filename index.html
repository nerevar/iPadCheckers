<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<title>HTML5 iPad Checkers</title>
		
		<script type="text/javascript" src="jquery.min.js"></script>
		<script type="text/javascript">
var canvas = null;
var context = null;
var cb_lastPoints = [];
var CELL_SIZE = 80;
var BOARD_SIZE = CELL_SIZE * 8;
var COLOR_BLACK = '#ededed';
var COLOR_WHITE = '#fff';
var SELECTION_COLOR = '#c0c';
var touching = false;
var images = {};
var diff_coords = {};
var last_coords = {};

var whiteTurn = true;

var pieces;

var isSelected = -1;

var Cell = function(y, x, kind) {
	this.y = y;
	this.x = x;
	this.isKing = false;
	this.isSelected = false;
	this.isWhite = kind == 'black' ? false : true;
	this.isBlack = kind == 'black' ? true : false;
};
			
window.onload = function(){
	var sources = {
		green: "./img/green.png",
		blue: "./img/blue.png"
	};
	
	loadImages(sources, function(){
		init();
	});
};


function loadImages(sources, callback){
	var loadedImages = 0;
	var numImages = 0;
	for (var src in sources) {
		numImages++;
	}
	for (var src in sources) {
		images[src] = new Image();
		images[src].onload = function(){
			if (++loadedImages >= numImages) {
				callback();
			}
		};
		images[src].src = sources[src];
	}
}

function init() {
	canvas = document.getElementById("canv");

	pieces = [
		new Cell(5, 0, 'white'), new Cell(5, 2, 'white'),
		new Cell(5, 4, 'white'), new Cell(5, 6, 'white'),
		new Cell(6, 1, 'white'), new Cell(6, 3, 'white'),
		new Cell(6, 5, 'white'), new Cell(6, 7, 'white'),
		new Cell(7, 0, 'white'), new Cell(7, 2, 'white'),
		new Cell(7, 4, 'white'), new Cell(7, 6, 'white'),
		
		new Cell(0, 1, 'black'), new Cell(0, 3, 'black'),
		new Cell(0, 5, 'black'), new Cell(0, 7, 'black'),
		new Cell(1, 0, 'black'), new Cell(1, 2, 'black'),
		new Cell(1, 4, 'black'), new Cell(1, 6, 'black'),
		new Cell(2, 1, 'black'), new Cell(2, 3, 'black'),
		new Cell(2, 5, 'black'), new Cell(2, 7, 'black')];
	
	if (canvas.getContext) {
		
		context = canvas.getContext('2d');
		
		canvas.onmousedown = onStart;
		canvas.onmousemove = onMove;
		canvas.onmouseup = onStop;
		
		canvas.ontouchstart = onStart;
		canvas.ontouchend = onStop;
		canvas.ontouchmove = onMove;
		
		refresh();
	}
}

function log(smth) {
	$('#info .text').html($('#info .text').html() + ' | ' + smth);
}

function refresh() {

	if (whiteTurn) {
		$('#info .turn').text('WHITE');
	} else {
		$('#info .turn').text('BLACK');
	}
    
	context.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);
	drawBoard();
	drawPieces();
}

function drawPieces() {
	for (i in pieces) {
		drawPiece(pieces[i]);
	}
}

function drawBoard(){
    for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
            if (i % 2 != j % 2) {
                context.fillStyle = COLOR_WHITE;
            } else {
                context.fillStyle = COLOR_BLACK;
            }
            context.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
	context.beginPath();
	for (var x = 0.5; x < BOARD_SIZE; x += CELL_SIZE) {
		context.moveTo(x, 0);
		context.lineTo(x, BOARD_SIZE);
	}
	for (var y = 0.5; y < BOARD_SIZE; y += CELL_SIZE) {
		context.moveTo(0, y);
		context.lineTo(BOARD_SIZE, y);
	}
	context.strokeStyle = "#ccc";
	context.stroke();
}

function drawPiece(cell){
	x = cell.x;
	y = cell.y;
	
	px = CELL_SIZE * x;
	py = CELL_SIZE * y;
	
	piece = cell.isWhite ? images.green : images.blue;
	if (cell.isSelected) {
		// шашку двигаем, значит на поле её не рисуем
		if (!touching) {
			context.drawImage(piece, px , py);
			
			// обводим шашку
			context.beginPath();
			r = CELL_SIZE / 2 - 1;
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
			context.closePath();
			context.strokeStyle = SELECTION_COLOR;
			context.stroke();			
		}
	} else {
		// рисуем обычную шашки
		context.drawImage(piece, px , py);
	}
}

function drawPieceXY(cell, x, y){
	px = x ? x : 0;
	py = y ? y : 0;
	
	piece = cell.isWhite ? images.green : images.blue;
	context.drawImage(piece, px , py);
	
	if (cell.isSelected) {
		// обводим шашку
		context.beginPath();
		r = CELL_SIZE / 2 - 1;
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, r++, 0, Math.PI * 2, false);
		context.closePath();
		context.strokeStyle = SELECTION_COLOR;
		context.stroke();		
	}
}

function onStart(e) {
	if (e.touches) {
		// Touch event
		coords = getCoords(e.touches[0]); // Get info for finger #1
	} else {
		// Mouse event
		coords = getCoords(e);
	}
	last_coords = coords;
	console.log(last_coords);
	
	diff_coords = {	x : coords.x - Math.floor(coords.x / CELL_SIZE) * CELL_SIZE, 
					y : coords.y - Math.floor(coords.y / CELL_SIZE) * CELL_SIZE};
	diff_board_coords = {	x : Math.floor(coords.x / CELL_SIZE), 
							y : Math.floor(coords.y / CELL_SIZE)};

	// проверка на попадание в шашку
	if (isHitChecker()) {
		
		// получаем выбранную шашку
		for (i in pieces) {
            // убираем выделение с других шашек
			if (pieces[i].isSelected) {
				pieces[i].isSelected = false;
			}
            
			if (pieces[i].x == diff_board_coords.x && pieces[i].y == diff_board_coords.y
                && (whiteTurn == pieces[i].isWhite))
            {
				isSelected = i;
				pieces[i].isSelected = true;
			}
		}
		
		touching = true;
	}
	
	return false;
}

// Called whenever cursor position changes after drawing has started
function onStop(e) {
	e.preventDefault();
	
	if (touching) {
		touching = false;

		if (isSelected >=0 ) {
			
			new_x = Math.ceil(last_coords.x / CELL_SIZE) - 1;
			if (new_x > 7) new_x = 7;
			if (new_x < 0) new_x = 0;
			
			new_y = Math.ceil(last_coords.y / CELL_SIZE) - 1;
			if (new_y > 7) new_y = 7;
			if (new_y < 0) new_y = 0;
			
			// переместили шашку
			if (pieces[isSelected].x != new_x || pieces[isSelected].y != new_y) {
                if (isEmpty(new_x, new_y)) {
                    pieces[isSelected].x = new_x;
                    pieces[isSelected].y = new_y;

                    pieces[isSelected].isSelected = false;
                    isSelected = -1;

                    whiteTurn = !whiteTurn;
                }
			}
			
			refresh();
		}
	}
	return false;
}


function onMove(e) {
	if (e.touches) {
		// Touch Enabled
		coords = getCoords(e.touches[0]); // Get info for finger i
	} else {
		coords = getCoords(e);
	}
	
	last_coords = coords;

	$('#info .x').text('X: ' + coords.x); $('#info .cx').text('CX: ' + Math.ceil(coords.x / CELL_SIZE));
	$('#info .y').text('Y: ' + coords.y); $('#info .cy').text('CY: ' + Math.ceil(coords.y / CELL_SIZE));


	if (touching) {		
		checker_coords = {	x : coords.x - diff_coords.x,
							y : coords.y - diff_coords.y};
		
		refresh();
		
		if (isSelected >= 0) {
			drawPieceXY(pieces[isSelected], checker_coords.x, checker_coords.y);
		}
	}

	return false;
}

// Draw a line on the canvas from (s)tart to (e)nd
function drawLine(sX, sY, eX, eY) {
	context.moveTo(sX, sY);
	context.lineTo(eX, eY);
	return { x: eX, y: eY };
}

// Get the coordinates for a mouse or touch event
function getCoords(e) {
	if (e.pageX == null && e.clientX != null ) { 
		var html = document.documentElement
		var body = document.body
	
		e.pageX = e.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
		e.pageY = e.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
	}
	return { x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop };
	
	/*if (e.offsetX) {
		return { x: e.offsetX, y: e.offsetY };
	}
	else if (e.layerX) {
		return { x: e.layerX, y: e.layerY };
	}
	else {
		return { x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop };
	}*/
}

function isHitChecker() {
	return Math.sqrt(Math.pow(diff_coords.x - (CELL_SIZE / 2), 2) + Math.pow(diff_coords.y - (CELL_SIZE / 2), 2)) <= (CELL_SIZE / 2);
}

function canMove(piece, x, y) {
    return true;
}
function isEmpty(x,y) {
    for (i in pieces) {
        if (pieces[i].x == x && pieces[i].y == y) {
            return false;
        }
    }
    return true;
}

		</script>
		<style type="text/css" media="screen">
			body {
				font: 14px Verdana;
			}
			#wrap {
				width: 768px;
				height:
				max-height: 1024px;
				overflow: hidden;
			}
			#canv_wrap {
				border: 1px solid #777;
				width: 640px;
				margin: 0px auto 0px;
			}
			#info {
				position:absolute;
			}
		</style>
	</head>
	<body>
		<div id="wrap">		
			<div id="info">
				<div class="turn"></div>
				<div class="x"></div>
				<div class="y"></div>
				<div class="cx"></div>
				<div class="cy"></div>
				<div class="text"></div>
			</div>
			
			<div id="canv_wrap">
				<canvas id="canv" width="640" height="640"></canvas>
			</div>

			
		
		</div>
	</body>
</html>